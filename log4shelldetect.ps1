 <#
    .SYNOPSIS
		Create list of domain-joined servers and scan them for log4j vulnerable libraries.
    .DESCRIPTION 
		See https://github.com/arnaudluti/PS-CVE-2020-44228/blob/main/README.md
    .NOTES
        Author: Arnaud Rigole
        Version: 1.0
        Date: 01/2022
	.EXAMPLE
		Initiate script
		./log4shelldetect.ps1
		Then retrieve logs
		./log4shelldetect.ps1 -update
	.EXAMPLE
		Initiate script with search pattern for AD computers
        ./log4shelldetect.ps1 -searchPattern '*tst*'
		Then retrieve logs
		./log4shelldetect.ps1 -update	
#>

Param (
    [string]$computerName,
    [string]$searchPattern,
    [switch]$update = $false,
    [switch]$list   = $false
)

# Static
$ErrorActionPreference = 'Stop'
[string]$checkTool = "$PSScriptRoot\log4shelldetect.exe"
[string]$serversList = "$PSScriptRoot\output-log4shelldetect.csv"

Write-Output "--"
Write-Output "[i] Using checktool: $($checkTool)"
Write-Output "[i] Using serverList : $($serversList)"
Write-Output "--"

# Functions
function invokeScanJob {
    Param (
        [string]$ComputerName,
        [string]$checkTool
    )
    Write-Output "[i] Waiting for binary to copy on  $($ComputerName) local filesystem..."
    New-Item -Type Directory -Path "\\$($computerName)\C$\WINDOWS\TEMP\LOG4SHELLDETECT\" -Force -ErrorAction continue | Out-Null
    Copy-Item $checkTool -Destination "\\$($computerName)\C$\WINDOWS\TEMP\LOG4SHELLDETECT\" -Recurse -Force  -ErrorAction continue | Out-Null

    $jn = 'job-chk-log4shell-' + $computerName
    Invoke-Command -ComputerName $ComputerName -ArgumentList $checkTool -AsJob -JobName $jn -ScriptBlock {
        Param (
            $checkTool
        )           
        [System.Collections.ArrayList]$tasks = @()
        $ErrorActionPreference = 'Stop'

        $drives = (Get-CimInstance Win32_LogicalDisk | Where-Object {$_.DriveType -eq '3'}).DeviceID # Better than Get-PSDrive because that last detects DVD reader...
        $toolPath = 'C:\WINDOWS\TEMP\LOG4SHELLDETECT\' + $(Split-Path $($checkTool) -Leaf)
    
        if (-not(Test-Path $toolPath)) {
            return 'missing-checktool-on-local-filesystem'
        }
    
        # Need to execute the task as SYSTEM to access every path (no network access)
        Try {
            Foreach ($d in $drives) {
                [string]$tn = "chk-log4shell-" + "$(($d).replace(':',''))"
                $taskPrincipal = New-ScheduledTaskPrincipal -GroupId "NT AUTHORITY\SYSTEM" -RunLevel Highest
                $taskAction  = New-ScheduledTaskAction -Execute "powershell.exe" -Argument "-NoProfile -WindowStyle Hidden -command `"$toolPath`" `"-mode list -include-zip '$($d)' | Out-File -Force -Append 'C:\WINDOWS\TEMP\LOG4SHELLDETECT\$($tn).txt'`""
                $taskTrigger = New-ScheduledTaskTrigger -Once -At (Get-Date).AddSeconds(+10)
                $taskSettings = New-ScheduledTaskSettingsSet -ExecutionTimeLimit (New-TimeSpan -Hours 2)
                Register-ScheduledTask -TaskName $tn -Trigger $taskTrigger -Action $taskAction -Principal $taskPrincipal -Settings $taskSettings -Force -ErrorAction stop | Out-Null
                $tasks.Add($tn) | Out-Null
            }
        } Catch {
            return 'task-creation-failed'
        }
        # Scheduled task status
        While (-not ($tasks.count -eq 0)) {
            Foreach ($tr in $tasks.clone()) {
                If ((Get-ScheduledTaskInfo -TaskName $tr).LastTaskResult -match '1|0') {
                    $tasks.Remove($tr) 
                    Unregister-ScheduledTask -TaskName $tr -Confirm:$false                              
                }
            }
            Start-Sleep -Seconds 15
        }
        # Concatenate results to generate output
        $vul = Get-ChildItem "C:\WINDOWS\TEMP\LOG4SHELLDETECT\chk-log4shell*" | Get-Content
        
        # Results & output of the job
        $vulcnt = $vul.count
        if ($vulcnt -eq 0) {              
            Remove-Item -Force -Recurse "C:\WINDOWS\TEMP\LOG4SHELLDETECT" # CleanUp
            return "tested-ok"
        } else {
            return "tested-vulnerable"
        }
    } | Out-Null
}
function listServers {
    Param(
        [System.Collections.ArrayList]$hServers
    )
    Write-Host -Fore Blue "[i] Listing servers list & status :"
    Write-Host -Fore Blue "Server list : $($serversList)"
    Write-Host -Fore Blue "--"
    $hServers
}
function retrieveAndUpdate {
    Param(
        [System.Collections.ArrayList]$hServers
    )
    Write-Host -Fore Blue "[i] Updating input file / server list"
    Get-Job -State 'Failed' | Foreach-Object {
        $jobServerName  = $_.Location
        $serverObj      = $hServers | Where-Object {$($_.Hostname) -eq $($jobServerName)}
        $jobName        = $_.Name
        $serverObj.State = 'test-failed'
        Write-Host -Fore Red "[x] Scan job failed on $($jobServerName). Please review : Receive-Job -Name $($jobName)."
    }
    Get-Job -State 'Completed' | Foreach-Object {
        $jobServerName  = $_.Location
        $serverObj      = $hServers | Where-Object {$($_.Hostname) -eq $($jobServerName)}
        $jobName        = $_.Name
        $outPut         = Receive-Job $jobName
        switch ($outPut) {
            'not-tested' {
                continue
            }            
            'tested-ok' {
                Write-Host "[i] Scan job finished on $($jobServerName). No vulnerable log4j libs detected."
                $serverObj.State = 'tested-ok'
                Remove-Job $jobName
            }            
            'tested-vulnerable' {
                Write-Host -Fore Red "[!] The server $($jobServerName) has vulnerable log4j libs on it. Retrieving log files..."
                Try {
                    $logPath = "$($PSScriptRoot)\logs-vulnerable\$($jobServerName)\"
                    New-Item -Type Directory -Path "$logPath" -Force | Out-Null
                    Copy-Item "\\$($jobServerName)\C$\WINDOWS\TEMP\LOG4SHELLDETECT\chk*.txt" -Destination $logPath -ErrorAction stop | Out-Null
                    Remove-Item -Force "\\$($jobServerName)\C$\WINDOWS\TEMP\LOG4SHELLDETECT\chk*.txt" # CleanUp
                    Write-Host "[i] Logs has been copied in $($logPath). Please review."
                } Catch {
                    Write-Host -Fore Yellow "[!] Could not retrieve logs on $($jobServerName). Please check manually. Error is: $($Error[0])"
                }
                $serverObj.State = 'tested-vulnerable'
                Remove-Job $jobName
            }
            'task-creation-failed' {
                Write-Host -Fore Yellow "[x] Could not create scan tasks on $($jobServerName). Missing Scheduled.Tasks PS module ?"
                $serverObj.State = 'task-creation-failed'
                Remove-Job $jobName
            }            
            'missing-checktool-on-local-filesystem' {
                Write-Host -Fore Yellow "[x] Could not create scan tasks on $($jobServerName). The check tool binary isn't present on local filesystem. Try again."
                $serverObj.State = 'missing-checktool-on-local-filesystem'
                Remove-Job $jobName
            }
            Default {
                Write-Host -Fore Grey "[x] Could not understand job output. Please check : Receive-Job -Name $($jobName) and remove it manually."
                $serverObj.State = 'output-not-identified'
            }
        }
    }    
    $hServers | Export-Csv $serversList -Encoding UTF8 -Force
}
function initialSetup {    
    Param (
        [string]$searchPattern,
        [System.Collections.ArrayList]$hServers
    )
    # Initial setup
    if (-not ($hServers)) {
        Write-Host -Fore Blue "[i] Initial setup. Creating server list."
        [System.Collections.ArrayList]$hServers = @()
    }    
    Import-Module ActiveDirectory
    Try {
        if ($searchPattern) {
            $servers = Get-AdComputer -Filter {(name -like $searchPattern) -and (Enabled -eq $true)} -properties OperatingSystem,DNSHostName | Where-Object {$_.OperatingSystem -match 'server'} | Select-Object OperatingSystem,DNSHostName
        } else {
            $servers = Get-AdComputer -Filter {Enabled -eq $true} -properties OperatingSystem,DNSHostName | Where-Object {$_.OperatingSystem -match 'server'} | Select-Object OperatingSystem,DNSHostName
        }
    } Catch {
        Write-Host -Fore Red "[x] Could not request AD to fill up server list. Aborting"
        exit 1
    }
    if (-not ($servers)) {
        Write-Host -Fore Red "[x] Your search pattern returned no results. Aborting."
        exit 1
    } 
    # Create objects from output & fill global hashtable
    $servers | Foreach-Object {
        $s = New-Object -TypeName PSCustomObject -Property @{
                HostName        =   $_.DNSHostName
                OperatingSystem =   $_.OperatingSystem
                ScannedDisks    =   ''
                State           =   ''
        }
        if ($($s.hostname) -notin $($hServers.hostname)) {
            Write-Host "[+] $($s.hostname) not in the check list, adding."
            $s.State = 'not-tested'
            $hServers+=$s
        } else {
            $state = ($hServers | Where-Object {$_.HostName -eq "$($s.HostName)"}).State
            Write-Host "[-] $($s.hostname) is already in the list, state is $($state), nothing to do."
        }
    }
    $hServers | Export-Csv $serversList -Encoding UTF8 -Force
    Write-Host -Fore Blue "[i] Server list created / updated."

    $q = Read-Host -p "[?] Would you like to launch the test jobs now ? (y/n)"
    if ($q.tolower() -eq 'y') {
        createScanJobsFromList -hServers $hServers
    } else {
        Write-Host "Aborting."
        exit 0
    }
}
function createScanJobsFromList {
    Param(
        [System.Collections.ArrayList]$hServers
    )
    # Tool we use to scan
    if (-not (Test-Path $checkTool)) {
        Write-Host -Fore Yellow "[!] Could not find your check tool, aborting."
        Exit 1
    }
    # Loop to create scan jobs
    Foreach ($s in $hServers) {
        Switch ($s.State) {
            'not-tested' {
                If (-not (Test-Connection -ComputerName $s.HostName -Count 1 -Quiet)) {
                    $s.State = 'unreachable'
                    continue
                } Else {
                    Write-Host -Fore Blue "[+] Starting scan job on $($s.HostName)"
                    invokeScanJob -computerName $($s.HostName) -checkTool $checkTool
                    $s.State = 'test-running'
                }
            }
            'tested-vulnerable' {
                If (-not (Test-Connection -ComputerName $s.HostName -Count 1 -Quiet)) {
                    $s.State = 'unreachable'
                    continue
                } Else {
                    Write-Host -Fore Blue "[+] Starting scan job on $($s.HostName)"
                    invokeScanJob -computerName $($s.HostName) -checkTool $checkTool
                    $s.State = 'test-running'
                }
            }            
            'tested-ok'   {
                continue
            }
            'unreachable' {
                continue
            }
        }   
    }
    exit 0 # EOF
}
# Run
if ($computerName) {
    Write-Host -Fore Blue "[i] Running manual check on $computerName"
    invokeScanJob -computerName $computerName -checkTool $checkTool
} else {
    if (-not (Test-Path $serversList)) {
        $q = Read-Host -p "[?] Run initial setup (create .csv from AD powershell module request) ? (y/n)"
        if ($q.tolower() -eq 'y') {
            if ($searchPattern) {   
                initialSetup -searchPattern $searchPattern
            } else {
                initialSetup
            }
        } else {
            Write-Output "Aborting..."
            exit 0
        }    
    }  else { 
        [System.Collections.ArrayList]$hServers = Import-Csv "$serversList"
        if ($update) {
            retrieveAndUpdate -hServers $hServers
            exit 0
        }
        if ($list) {
            listServers -hServers $hServers
            exit 0
        }
        if ($searchPattern) {
            Write-Host -Fore Blue "[i] Running bulk test on domain servers with specified pattern $searchPattern"   
            initialSetup -searchPattern $searchPattern -hServers $hServers
            createScanJobsFromList -hServers $hServers
        } else {
            Write-Host -Fore Blue "[i] Running bulk test on domain servers"
            createScanJobsFromList -hServers $hServers
        }
    }
}